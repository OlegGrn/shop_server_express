Логирование:
1 Получаем email, password.
2  Проверяем базу на наличие юзера и если есть такой, пароль.
3 Если нет такого или неверный пароль ошибка.
4 Если всё верно, делаем payload (сделать отдельную функцию)
5 предаем payload в сервис по токенам,
6     Сервис по токенам:
     - делает два токена, один из которых прописывает в базе
     - прежде чем прописать - проверяет, есть ли в базе ID юзера
     - если есть - перезаписывает старый, если нет - делает запись
     - сервис возвращает два токена
7 Возвращаем токены
8 Полученные токены: один - в куки, второй в ответе и статус 200
 
Разбивка: 
   1,8 - Котролер
   2,3,4,5,6,7 - сервис
   (4)- сделать отдельную функцию для payload
   (6)- сервис по токенам

Регистрация:
1 Проверяем пароль и почту на валидность, ошибка если не валидны
   - можно использовать встроенный сервис от express-validator
2 проверяем базу на наличие уже юзера с такой почтой, ошибка если уже есть
3 хешируем пароль
4 создаем пользователя как Юзера ( + Роль + Корзину) и получаем его из базы
5 делаем payload 
6 предаем payload в сервис по токенам, и делаем токены
7 возвращаем токены
8 полученные токены: один - в куки, второй в ответе и статус 200

Разбивка;
   1,8 - котролер
   2,3,4,5,6,7 - сервис
   (5)- отдельная функция для payload
   (6)- сервис по токенам
   (1) - отдельная функция на валидность????
 


Выход из логина:
1 Из запроса получаем рэфрэш куку / req.coookies возвращает объект куки
1 Из запроса получаем рэфрэш куку / req.coookies возвращает объект куки
3 токен сервис: 
  - по токену находит в базе запись и удаляет её
  - возвращает что-то (например саму куку)
4 получив успешный ответ, =>
5 удаляем куку из самого запроса res.clearCookie('название')
6 возвращаем ответ, статус 200

Разбивка:
 1,5,6 котроллер
 2,3,4 - сервис
 (3) токен сервис

Рефреш обеих токенов:
срабатывает автоматом на 401 ошибку (unauthorized)
...Если AccessToken умер,  проверяем что refreshToken валидный и перезаписываем оба...
Вариант1:
Проверяем сначала refreshToken. Если его нет или не валидный или в базе прописан другой токен - ошибка 400,
что пользователь не авторизован =>
=> пользователь заново логинится и получает оба токена.
Если всё хорошо (refreshToken валидный), то обновляем оба токена. refreshToken перезаписываем в базе и ставим в куки,
а accessToken возвращаем на клиент.

Вариант2:
 - если refreshToken токен валидный, и в базе прописан другой, то ошибку 400 НЕ возвращаем.
 Вместо этого обновляем оба токена. refreshToken перезаписываем в базе и ставим в куки,
 а accessToken возвращаем на клиент



 - проверить
 - сгенерировать новый
 - установить в куки
 - отправить на клиент

1 Из запроса получаем рэфрэш куку / req.coookies возвращает объект куки
2 Сервис получет refreshToken =>
3 если refreshToken нет - ошибка 400 (пользователь не авторизован) !!! Внимание НЕ 401 ошбика
4 вызываем токен Сервис, для его валидации => в токен Сервисе:
   - проверяем токен на валидацию
   - при ошибке валидации, возвращаем просто NULL, (наверно можно выкинуть и ошибку)
   - если все хорошо, возвращаем, например зашитый в токен payload
5 Так же проверяем что в базе действительно есть тот самый токен из куки,
поскольку может быть, что токен хоть и валидный, но уже недействительный.
Например юзер входил с другого устройства или браузера и перезаписал по своему ID новый токен в базе
6 Если вернулся NULL по пункту 4 или 5 - ошибка 400 (пользователь не авторизован) !!! Внимание НЕ 401 ошбика
7 Если все хорошо, то делаем новый payload, поскольку за эти 30 дней данные по пользователю могли измениться
8 Формируем новую пару токенов и возвращаем в котролер
9 Устанавливаем один токен в куку, второй в ответе и статус 200

(7) - нет смысла, так как эта опция на рефреш токенов с временем жизни 15 минут (AccessToken)

Разбивка:
 1,9 - контролер
 2,3,(4),(5),6,7,8 - сервис
 (4,5) - токен сервис = две новых функции:
    - проверка токена (сразу делаем две, по оной на каждый токен
    - поиск токена в базе


Мидлвээр проверка полномочий checkPowers
1 Принимает массив полномочий и возвращаем функцию
2 Если "OPTIONS" - return next() ??
3 получаем строку (AccessToken из req.headers.authorization в виде строки) с токеном из заголовка, 
  если его нет - ошибка 401
4 из строки получаем токен
5 вызываем сервис Токен по валидации
6 если ок, на выходе payload, иначе ошибка 401
7 прогоняем доступные роли через роли из payload
8 если хоть одной доступной нет, счетчик уменьшится
9 на выходи или next() или next(с ошибкой 400)


Добавление нового ADMIN:
1 предвариетльно Мидлвээр проверяет полномочия на запрос и валидность ACCESS токена
2 полчучем из запроса email на кандидата и передаем в сервис
3 в сервисе, проверяем, есть ли такой Юзер в базе, если нет - ошибка 400
4  + проверяем по базе ролей, может у юзера уже есть роль админ
4 добавляем роль Админа кандидату
5 возвращам в контролёр что-то (или нет)
6 ответ клиенту
     Разбивка:
     1,6 - контролер
     2,3,4,5, - сервис

/////   НЕ РАБОТАЕТ ДЛЯ УСЛОВИЙ ДВУХ ТОКЕНОВ ////////
проверка AUTH (ОБРАБАТЫВАЕТ ТОЛЬКО ОДНИ ТОКЕН AccessToken)
 - обрабатывает только AccessToken, поэтому если был выход(logout, и удаление refreshToken)
   то проверка AUTH всё равно показывает что авторизован (пока AccessToken валидный). Это можно
   поправить, если после пункта 4 проверять еще пользователя по базе Token (отсутстви пользователя 
   в этой базе указывает что был logout). 
   Замечание: если проверять, что в базе токенов есть такой юзер по ID, то так же можно ошибиться - поскольку, 
   пользователь мог зайти с друго компа и перезаписать токкен.
   ВЫВОД: ПРИ НАЛИЧИИ ДВУХ ТОКЕНОВ, ПРОВРКУ НАДО ДЕЛАТЬ ПО ДВУМ ТОКЕНАМ ОДНОВРЕМЕННО 
1 получаем AccessToken из req.headers.authorization в виде строки и 
2 передаем в сервис
3 В сервисе, если ничего нет в этой строке - ошибка 401
4 затем ввызываем сервис Токен по валидации
4 если ок, на выходе payload, иначе ошибка 401
5 возвращем на клиент ответ - 200 и ...??? может даные по юзеру?
/////////////////////////////////////////////////////////////////////////
               НОВАЯ ВЕРСИЯ ПО ОДНОМУ ТОКЕНУ refreshToken - ПРОВЕРКА НА СТАРТЕ ПРИЛОЖЕНИЯ
               эта опция только для проверки на старте приложения, потом уже будет рефреш
проверка AUTH (ОБРАБАТЫВАЕТ ТОЛЬКО ОДНИ ТОКЕН refreshToken)
1 Контролер получает токен из куки
2 передаем его в сервис
3 В сервисе, если ничего нет в refreshToken - ошибка 400 не авторизован
4 затем ввызываем сервис Токен по валидации
4 если ок, на выходе payload, иначе ошибка 400 не авторизован
5 проверяем что в базе записан именно этот токен по id юзера
6 если нет, ошбка 400 - не авторизован

5 возвращем на клиент ответ - 200 и ...??? может даные по юзеру?


 













 

 





